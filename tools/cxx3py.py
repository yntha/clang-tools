import ast
import sys
import io
import re
import keyword

from clang.cindex import TypeKind, CursorKind

tk2prim = {
  TypeKind.BOOL: '?',
  TypeKind.SCHAR: 'b',
  TypeKind.CHAR_S: 'b',
  TypeKind.UCHAR: 'B',
  TypeKind.CHAR_U: 'B',
  TypeKind.SHORT: 'h',
  TypeKind.USHORT: 'H',
  TypeKind.INT: 'i',
  TypeKind.UINT: 'I',
  TypeKind.LONG: 'l',
  TypeKind.ULONG: 'L',
  TypeKind.LONGLONG: 'q',
  TypeKind.ULONGLONG: 'Q',
  TypeKind.FLOAT: 'f',
  TypeKind.DOUBLE: 'd',
  TypeKind.POINTER: 'P'
}

# https://stackoverflow.com/a/1176023
def camel_to_snake(name):
  name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
  name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name).lower()
  
  return unreserve(name)

def is_reserved(name):
  return (name in __builtins__.__dict__ or keyword.iskeyword(name))

def unreserve(name):
  return ('x_' + name if is_reserved(name) else name)

class recordparser:
  @classmethod
  def get_member_fmt(cls, member):
    ctype = member.type
    
    if ctype.get_declaration().kind == CursorKind.UNION_DECL:
      largest = (0, None)
      
      for field in ctype.get_declaration().get_children():
        sz = field.type.get_size()
        bias = field.type.get_canonical().kind != TypeKind.RECORD
        bias = bias and (largest[0] == sz)
        
        if sz > largest[0] or bias:
          largest = (sz, field.type, field)
      
      kind = largest[1].get_canonical().kind
      
      if kind == TypeKind.RECORD:
        member_sz = largest[1].get_size()
        
        # just return a byte array
        return '%dc' % member_sz
      
      if kind == TypeKind.CONSTANTARRAY:
        return '%d%s' % (
          largest[1].get_array_size(),
          tk2prim[largest[1].get_array_element_type().kind]
        )
      
      return tk2prim[largest[1].get_canonical().kind]
    
    unsugared = ctype.get_canonical()
    
    if unsugared.kind in tk2prim:
      return tk2prim[unsugared.kind]
    
    if unsugared.kind == TypeKind.CONSTANTARRAY:
      arr_type = unsugared.get_array_element_type()
      
      # this can make humogus strings!!1! :D
      if arr_type.kind == TypeKind.RECORD:
        formats = []
        
        for i in range(unsugared.get_array_size()):
          formats.append(cls.get_record_fmt(arr_type))
        
        return ''.join(formats)
      
      return '%d%s' % (
        unsugared.get_array_size(),
        tk2prim[unsugared.get_array_element_type().kind]
      )
    
    decl = ctype.get_declaration()
    
    if decl.location.file is None:
      return None
    
    if decl.location.file.name != ast.imaginary_file:
      return None
    
    if ctype.kind == TypeKind.ENUM:
      # sorry, no enum support yet.
      return 'i'
    
    return cls.get_record_fmt(ctype)
  
  @classmethod
  def get_record_fmt(cls, record):
    children = record.get_declaration().get_children()
    formats = []
    
    for child in children:
      ctype = child.type
      decl = ctype.get_declaration()
      
      if ctype.kind in (TypeKind.RECORD, TypeKind.ELABORATED):
        if ctype.kind == TypeKind.ELABORATED:
          child_parent = child.semantic_parent
          type_parent = decl.semantic_parent
          
          if child_parent == type_parent:
            if decl.is_anonymous():
              continue
      
      fmt = cls.get_member_fmt(child)
      
      if fmt is None:
        continue
      
      formats.append(fmt)
    
    return ''.join(formats)
  
  @classmethod
  def translate_type(cls, ctype):
    unsugared = ctype.get_canonical()
    
    if unsugared.kind == TypeKind.POINTER:
      # doesn't matter if its a const char *, it still is a pointer, which when
      # read, is a numerical value.
      return 'int'
    
    if unsugared.spelling.endswith('char'):
      if unsugared.kind == TypeKind.CONSTANTARRAY:
        return 'bytes'
      
      return 'int'
    
    if unsugared.kind == TypeKind.CONSTANTARRAY:
      return 'list'
    
    if unsugared.kind == TypeKind.FLOAT:
      return 'float'
    
    base_type = unsugared.spelling.split(' ')[-1]
    if base_type in ('int', 'long', 'short', 'double'):
      return 'int'
    
    if ctype.kind == TypeKind.BOOL:
      return 'bool'
    
    if ctype.kind == TypeKind.VOID:
      return 'None'
    
    if ctype.get_declaration().kind == CursorKind.UNION_DECL:
      return 'int'
    
    return ctype.spelling

class codegen:
  pycode = io.StringIO()
  indent = 2
  indent_lvl = 0
  
  @classmethod
  def write(cls, text):
    cls.pycode.write((' ' * (cls.indent * cls.indent_lvl)) + text)
  
  @classmethod
  def writeline(cls, text, newlines = 1):
    cls.write(text + ('\n' * newlines))
  
  @classmethod
  def file_header(cls):
    cls.writeline("# Autogenerated by cxx3py.")
    cls.writeline('# https://github.com/yntha', 2)
    cls.writeline("from dataclasses import dataclass", 2)
    
    # this decorator adds a new class variable to a translated struct.
    # the variable is named 'format' and it describes the dataclass in
    # a format that can be passed to struct.unpack().
    cls.writeline('def cxx3py(format):')
    cls.indent_lvl += 1
    cls.writeline('def wrapper(klass):')
    cls.indent_lvl += 1
    cls.writeline('klass.format = format', 2)
    cls.writeline('return klass')
    cls.indent_lvl -= 1
    cls.writeline('return wrapper', 2)
    cls.indent_lvl -= 1
  
  @classmethod
  def struct_header(cls, struct):
    cls.writeline('# L%d: %s' % (
      struct.get_declaration().location.line,
      cls.get_type_spelling(struct)
    ))
    cls.writeline('@dataclass')
    cls.writeline('@cxx3py("%s")' % recordparser.get_record_fmt(struct))
    cls.writeline("class %s:" % unreserve(struct.spelling))
  
  @classmethod
  def struct_member(cls, member, default = None):
    if member.type.kind == TypeKind.INVALID:
      return
    
    cls.indent_lvl += 1
    cls.writeline('# %s%s;' % (
      cls.get_type_spelling(member.type),
      member.spelling
    ))
    
    translated_type = None
    if member.is_bitfield():
      field_width = member.get_bitfield_width()
      cls.writeline('# Bitfield width: %d' % field_width)
      
      # uncanonical way of declaring a boolean
      if field_width == 1:
        translated_type = 'bool'
    else:
      translated_type = recordparser.translate_type(member.type)
    
    cls.writeline('%s: %s%s # Format: "%s"' % (
      camel_to_snake(member.spelling),
      translated_type,
      (' = %s' % default if default is not None else ''),
      recordparser.get_member_fmt(member)
    ), 2)
    cls.indent_lvl -= 1
  
  @classmethod
  def get_type_spelling(cls, ctype):
    decl = ctype.get_declaration()
    spelling = ctype.spelling
    
    if decl.is_anonymous():
      if decl.kind == CursorKind.UNION_DECL:
        spelling = 'union <anon> {...}; '
      
      if decl.kind == CursorKind.STRUCT_DECL:
        spelling = 'struct <anon> {...}; '
    elif decl.kind == CursorKind.STRUCT_DECL:
      spelling = 'struct %s {...};' % spelling
    elif decl.kind == CursorKind.UNION_DECL:
      spelling = 'union %s {...};' % spelling
    else:
      if spelling[-1] != '*':
        spelling += ' '
    
    return spelling

def main():
  cpp = ast.CLangAST(sys.argv[1])
  
  codegen.file_header()
  # convert structs to python dataclasses
  for struct in cpp.structs():
    codegen.struct_header(struct)
    
    for field in struct.get_declaration().get_children():
      if field.kind == CursorKind.UNION_DECL:
        continue
      
      codegen.struct_member(field)
    
    codegen.writeline('')
  
  print(codegen.pycode.getvalue())

main()